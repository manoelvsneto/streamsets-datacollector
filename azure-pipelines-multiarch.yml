# Azure DevOps Pipeline para StreamSets Data Collector - Multi-arquitetura
# Suporte para AMD64 e ARM64

pool:
  name: Arm64
  vmImage: 'ubuntu-22.04'

trigger:
  branches:
    include:
    - main
  paths:
    exclude:
    - README.md
    - docs/*
    - '*.md'

pr:
  branches:
    include:
    - main

variables:
  # Container Registry Service Connection
  dockerRegistryServiceConnection: 'DockerConnection'
  imageRepository: 'manoelvsneto/streamsets-datacollector'
  containerRegistry: 'DockerConnection'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile.multiarch'
  tag: '$(Build.BuildId)'
  
  # Azure Kubernetes Service
  kubernetesServiceConnection: 'K8SOracleCloud'
  kubernetesNamespace: 'streamsets'
  
  # Agent VM image name
  vmImageName: 'ubuntu-22.04'

stages:
- stage: Build
  displayName: Build Multi-Architecture
  jobs:
  - job: BuildMultiArch
    displayName: Build Multi-Architecture Image
    pool:
      vmImage: $(vmImageName)
    steps:
    # Setup Docker Buildx for multi-architecture builds
    - task: DockerInstaller@0
      displayName: Install Docker
      inputs:
        dockerVersion: '24.0.0'
        
    - script: |
        # Setup Docker Buildx
        docker buildx create --name multiarch-builder --driver docker-container --bootstrap
        docker buildx use multiarch-builder
        docker buildx inspect --bootstrap
      displayName: 'Setup Docker Buildx'

    # Build and push multi-architecture image
    - task: Docker@2
      displayName: Build and Push Multi-Architecture Image
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)
          latest
        arguments: |
          --platform linux/amd64,linux/arm64
          --build-arg SDC_VERSION=6.0.0-SNAPSHOT
          --build-arg SDC_LIBS=streamsets-datacollector-jdbc-lib,streamsets-datacollector-jython_2_7-lib

    # Test the built image on current architecture
    - script: |
        echo "üß™ Testando imagem constru√≠da..."
        # Pull the image for current architecture
        docker pull $(imageRepository):$(tag)
        
        # Run container in background
        docker run -d --name streamsets-test -p 18630:18630 $(imageRepository):$(tag)
        
        # Wait for container to start
        sleep 30
        
        # Health check
        for i in {1..10}; do
          if curl -f http://localhost:18630/ &>/dev/null; then
            echo "‚úÖ StreamSets est√° respondendo"
            break
          fi
          echo "‚è≥ Aguardando StreamSets iniciar... (tentativa $i)"
          sleep 10
        done
        
        # Cleanup
        docker stop streamsets-test
        docker rm streamsets-test
      displayName: 'Test Built Image'
      continueOnError: true

    # Publish Kubernetes manifests
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Kubernetes manifests'
      inputs:
        pathToPublish: '$(Build.SourcesDirectory)/k8s'
        artifactName: 'k8s-manifests'

    # Generate SBOM (Software Bill of Materials)
    - script: |
        echo "üìã Gerando SBOM da imagem..."
        # Install syft for SBOM generation
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
        
        # Generate SBOM
        syft $(imageRepository):$(tag) -o spdx-json > streamsets-sbom.json
        
        echo "‚úÖ SBOM gerado: streamsets-sbom.json"
      displayName: 'Generate SBOM'
      continueOnError: true

    # Publish SBOM as artifact
    - task: PublishBuildArtifacts@1
      displayName: 'Publish SBOM'
      inputs:
        pathToPublish: 'streamsets-sbom.json'
        artifactName: 'sbom'
      condition: succeededOrFailed()

- stage: SecurityScan
  displayName: Security Scanning
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: ContainerScan
    displayName: Container Security Scan
    pool:
      vmImage: $(vmImageName)
    steps:
    # Container vulnerability scanning with Trivy
    - script: |
        echo "üîç Executando scan de seguran√ßa..."
        # Install Trivy
        sudo apt-get update
        sudo apt-get install wget apt-transport-https gnupg lsb-release
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install trivy
        
        # Scan the image
        trivy image --exit-code 0 --format json --output trivy-report.json $(imageRepository):$(tag)
        trivy image --exit-code 1 --severity HIGH,CRITICAL $(imageRepository):$(tag)
      displayName: 'Container Security Scan'
      continueOnError: true

    # Publish security scan results
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Security Scan Results'
      inputs:
        pathToPublish: 'trivy-report.json'
        artifactName: 'security-scan'
      condition: succeededOrFailed()

- stage: Deploy_Prod
  displayName: Deploy to Production
  dependsOn: 
  - Build
  - SecurityScan
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: Deploy
    displayName: Deploy to Kubernetes Production
    pool:
      vmImage: $(vmImageName)
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadBuildArtifacts@0
            inputs:
              artifactName: 'k8s-manifests'
              downloadPath: '$(System.ArtifactsDirectory)'

          - task: Kubernetes@1
            displayName: 'Create namespace'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: $(kubernetesServiceConnection)
              command: 'apply'
              arguments: '-f $(System.ArtifactsDirectory)/k8s-manifests/namespace.yaml'

          - task: Kubernetes@1
            displayName: 'Deploy ConfigMap and Secrets'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: $(kubernetesServiceConnection)
              command: 'apply'
              arguments: '-f $(System.ArtifactsDirectory)/k8s-manifests/configmap.yaml -f $(System.ArtifactsDirectory)/k8s-manifests/secret.yaml --namespace=streamsets'

          - task: Kubernetes@1
            displayName: 'Deploy Storage'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: $(kubernetesServiceConnection)
              command: 'apply'
              arguments: '-f $(System.ArtifactsDirectory)/k8s-manifests/persistent-volume.yaml --namespace=streamsets'

          - task: Kubernetes@1
            displayName: 'Deploy Application'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: $(kubernetesServiceConnection)
              command: 'apply'
              arguments: '-f $(System.ArtifactsDirectory)/k8s-manifests/deployment.yaml --namespace=streamsets'

          - task: Kubernetes@1
            displayName: 'Deploy Services and Ingress'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: $(kubernetesServiceConnection)
              command: 'apply'
              arguments: '-f $(System.ArtifactsDirectory)/k8s-manifests/service.yaml -f $(System.ArtifactsDirectory)/k8s-manifests/ingress.yaml --namespace=streamsets'

          - task: Kubernetes@1
            displayName: 'Update deployment image'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: $(kubernetesServiceConnection)
              command: 'set'
              arguments: 'image deployment/streamsets-datacollector streamsets-datacollector=$(imageRepository):$(tag) --namespace=streamsets'

          - task: Kubernetes@1
            displayName: 'Wait for deployment'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: $(kubernetesServiceConnection)
              command: 'rollout'
              arguments: 'status deployment/streamsets-datacollector --namespace=streamsets --timeout=600s'

          # Deployment verification
          - script: |
              echo "üîç Verificando deployment..."
              kubectl get pods -n streamsets -l app=streamsets-datacollector
              kubectl get svc -n streamsets -l app=streamsets-datacollector
              kubectl get ingress -n streamsets
              
              echo "‚úÖ Deploy conclu√≠do com sucesso!"
              echo "üåê StreamSets dispon√≠vel em: https://streamsets.archse.eng.br"
            displayName: 'Verify Deployment'
